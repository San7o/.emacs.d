;; -*- coding: utf-8-emacs; -*-
(setq nnrss-group-data '((15 (26612 60421 46271 981000) "https://emacsredux.com/blog/2025/04/06/goodbye-setq-hello-setopt/" "Goodbye setq, hello setopt!" nil "Sun, 06 Apr 2025 16:14:00 +0000" "For many years most Emacs users used setq to set the various configuration options of Emacs and the packages that they were using. This probably wasn’t the best option (read on), but it was the most popular way of doing things. Now, however, it’s finally time for a change!1 Why do we need setopt? In Emacs 29, a new macro setopt was introduced to provide a more appropriate method for setting user options (variables defined with defcustom). As mentioned above, traditionally, Emacs users have employed setq to assign values to variables. However, setq does not invoke any custom setter functions associated with user options, which can lead to unexpected behavior. Here’s example of such a setter function from copilot.el: (defun copilot--lsp-settings-changed (symbol value) \"Restart the Copilot LSP due to SYMBOL changed to VALUE. This function will be called by the customization framework when the `copilot-lsp-settings' is changed. When changed with `setq', then this function will not be called.\" (let ((was-bound (boundp symbol))) (set-default symbol value) (when was-bound ;; Notifying the agent with the new value does only work if we include the ;; last value (as nil) as well. For example, having the value ;; '(:github-enterprise (:uri \"https://example2.ghe.com\")) and setting it ;; to nil would require to send the value '(:github-enterprise (:uri nil)) ;; to the server. Otherwise, the value is ignored, since sending nil is ;; not enough. (copilot--start-agent)))) (defcustom copilot-lsp-settings nil \"Settings for the Copilot LSP server. This value will always be sent to the server when the server starts or the value changes. See https://github.com/github/copilot-language-server-release?tab=readme-ov-file#configuration-management for complete documentation. To change the value of this variable, the customization framework provided by Emacs must be used. Either use `setopt' or `customize' to change the value. If the value was set without the customization mechanism, then the LSP has to be manually restarted with `copilot-diagnose'. Otherwise, the change will not be applied. For example to use GitHub Enterprise use the following configuration: '(:github-enterprise (:uri \\\"https://example.ghe.com\\\")) Exchange the URI with the correct URI of your organization.\" :set #'copilot--lsp-settings-changed :type 'sexp :group 'copilot :package-version '(copilot . \"0.2\")) In case it’s not obvious - the important thing is the :set property of copilot-lsp-settings. Basically, every time this option is changed, a callback function should be invoked, but this won’t happen if you make the change using setq. The setopt macro addresses this by ensuring that when you set a user option, any associated setter functions are properly called, maintaining the integrity of the option’s behavior. Even more importantly for me - setopt also checks whether the value is valid for the user option. For instance, using setopt to set a user option defined with a number type to a string will signal an error. I’m pretty sure this will prevent a lot of (weird) configuration issues going forward! (and inspire more package authors to declare their defcustoms properly) Now let’s update a bit of legacy code to use setopt: (setq user-full-name \"Bozhidar Batsov\" user-mail-address \"bozhidar@emacsninja.com\") ;; Always load newest byte code (setq load-prefer-newer t) ;; reduce the frequency of garbage collection by making it happen on ;; each 50MB of allocated data (the default is on every 0.76MB) (setq gc-cons-threshold 50000000) ;; warn when opening files bigger than 100MB (setq large-file-warning-threshold 100000000) ;; quit Emacs directly even if there are running processes (setq confirm-kill-processes nil) This will be become: (setopt user-full-name \"Bozhidar Batsov\" user-mail-address \"bozhidar@emacsninja.com\") ;; Always load newest byte code (setopt load-prefer-newer t) ;; reduce the frequency of garbage collection by making it happen on ;; each 50MB of allocated data (the default is on every 0.76MB) (setopt gc-cons-threshold 50000000) ;; warn when opening files bigger than 100MB (setopt large-file-warning-threshold 100000000) ;; quit Emacs directly even if there are running processes (setopt confirm-kill-processes nil) Pretty shocking, right? When to Use What? The introduction of setopt has sparked discussions within the Emacs community regarding the best practices for setting variables. Some users have expressed uncertainty about when to use setq, customize-set-variable, or the new setopt. My take on the subject is pretty simple: Use setopt for user options to ensure that any custom setter functions are invoked. It has shorter name then customize-set-variable and can be used to set multiple options just like setq. Shows a warning when a configuration value does not match its :type specification. Unlike setq, it does not complain when a variable is not declared. (which is quite normal when dealing with a lot of autoloaded packages) Use setq only for variables that are not defined in terms of defcustom. Amusingly, setopt will work with regular variables as well, but it won’t be as efficient as setq. Not to mention using it in such a way will be super confusing! The way I see it, unless you’re running an older Emacs version, and you’re not using setopt extensively in your Emacs config, you’re missing out! Further Reading For more detailed discussions and perspectives on this topic, check out: Reddit Thread: Why was setopt introduced in Emacs 29? Emacs Stack Exchange: Which option to use for setting a variable Check out the official Emacs docs on setopt as well. Closing Thoughts I always knew that setq was flawed, but I kept using it for ages mostly because of inertia. I didn’t like the long name of customize-set-variable and I never use the M-x customize directly. I guess that’s why I rarely bothered to have setter callbacks in the packages that I wrote and maintain. Going forward I’ll certainly reconsider this. That’s all I have for you today. If you haven’t adopted setopt already, go wild and setopt all the things! How big of a change? Depends on whether you’re using use-package and how exactly are you using it! :D (in case you’re wondering - :custom settings are handled with customize-set-variable internally) ↩ (...)" nil nil "ad685653d5c40b317303f6aa780a35b8") (14 (26611 25560 456277 413000) "https://emacsredux.com/blog/2025/04/06/goodbye-setq-hello-setopt/" "Goodbye setq, hello setopt!" nil "Sun, 06 Apr 2025 16:14:00 +0000" "For many years most Emacs users used setq to set the various configuration options of Emacs and the packages that they were using. This probably wasn’t the best option (read on), but it was the most popular way of doing things. Now, however, it’s finally time for a change!1 Why do we need setopt? In Emacs 29, a new macro setopt was introduced to provide a more appropriate method for setting user options (variables defined with defcustom). As mentioned above, traditionally, Emacs users have employed setq to assign values to variables. However, setq does not invoke any custom setter functions associated with user options, which can lead to unexpected behavior. Here’s example of such a setter function from copilot.el: (defun copilot--lsp-settings-changed (symbol value) \"Restart the Copilot LSP due to SYMBOL changed to VALUE. This function will be called by the customization framework when the `copilot-lsp-settings' is changed. When changed with `setq', then this function will not be called.\" (let ((was-bound (boundp symbol))) (set-default symbol value) (when was-bound ;; Notifying the agent with the new value does only work if we include the ;; last value (as nil) as well. For example, having the value ;; '(:github-enterprise (:uri \"https://example2.ghe.com\")) and setting it ;; to nil would require to send the value '(:github-enterprise (:uri nil)) ;; to the server. Otherwise, the value is ignored, since sending nil is ;; not enough. (copilot--start-agent)))) (defcustom copilot-lsp-settings nil \"Settings for the Copilot LSP server. This value will always be sent to the server when the server starts or the value changes. See https://github.com/github/copilot-language-server-release?tab=readme-ov-file#configuration-management for complete documentation. To change the value of this variable, the customization framework provided by Emacs must be used. Either use `setopt' or `customize' to change the value. If the value was set without the customization mechanism, then the LSP has to be manually restarted with `copilot-diagnose'. Otherwise, the change will not be applied. For example to use GitHub Enterprise use the following configuration: '(:github-enterprise (:uri \\\"https://example.ghe.com\\\")) Exchange the URI with the correct URI of your organization.\" :set #'copilot--lsp-settings-changed :type 'sexp :group 'copilot :package-version '(copilot . \"0.2\")) In case it’s not obvious - the important thing is the :set property of copilot-lsp-settings. Basically, every this this option is changed, a callback function should be invoked, but this won’t happen if you make the change using setq. The setopt macro addresses this by ensuring that when you set a user option, any associated setter functions are properly called, maintaining the integrity of the option’s behavior. Even more importantly for me - setopt also checks whether the value is valid for the user option. For instance, using setopt to set a user option defined with a number type to a string will signal an error. I’m pretty sure this will prevent a lot of (weird) configuration issues going forward! (and inspire more package authors to declare their defcustoms properly) Now let’s update a bit of legacy code to use setopt: (setq user-full-name \"Bozhidar Batsov\" user-mail-address \"bozhidar@emacsninja.com\") ;; Always load newest byte code (setq load-prefer-newer t) ;; reduce the frequency of garbage collection by making it happen on ;; each 50MB of allocated data (the default is on every 0.76MB) (setq gc-cons-threshold 50000000) ;; warn when opening files bigger than 100MB (setq large-file-warning-threshold 100000000) ;; quit Emacs directly even if there are running processes (setq confirm-kill-processes nil) This will be become: (setopt user-full-name \"Bozhidar Batsov\" user-mail-address \"bozhidar@emacsninja.com\") ;; Always load newest byte code (setopt load-prefer-newer t) ;; reduce the frequency of garbage collection by making it happen on ;; each 50MB of allocated data (the default is on every 0.76MB) (setopt gc-cons-threshold 50000000) ;; warn when opening files bigger than 100MB (setopt large-file-warning-threshold 100000000) ;; quit Emacs directly even if there are running processes (setopt confirm-kill-processes nil) Pretty shocking, right? When to Use What? The introduction of setopt has sparked discussions within the Emacs community regarding the best practices for setting variables. Some users have expressed uncertainty about when to use setq, customize-set-variable, or the new setopt. My take on the subject is pretty simple: Use setopt for user options to ensure that any custom setter functions are invoked. It has shorter name then customize-set-variable and can be used to set multiple options just like setq. Shows a warning when a configuration value does not match its :type specification. Unlike setq, it does not complain when a variable is not declared. (which is quite normal when dealing with a lot of autoloaded packages) Use setq only for variables that are not defined in terms of defcustom. Amusingly, setopt will work with regular variables as well, but it won’t be as efficient as setopt. Not to mention using it in such a way will be super confusing! The way I see it, unless you’re running an older Emacs version, and you’re not using setopt extensively in your Emacs config, you’re missing out! Further Reading For more detailed discussions and perspectives on this topic, check out: Reddit Thread: Why was setopt introduced in Emacs 29? Emacs Stack Exchange: Which option to use for setting a variable Check out the official Emacs docs on setopt as well. Closing Thoughts I always knew that setq was flawed, but I kept using it for ages mostly because of inertia. I didn’t like the long name of customize-set-variable and I never use the M-x customize directly. I guess that’s why I rarely bothered to have setter callbacks in the packages that I wrote and maintain. Going forward I’ll certainly reconsider this. That’s all I have for you today. If you haven’t adopted setopt already, go wild and setopt all the things! How big of a change? Depends on whether you’re using package.el and how exactly are you using it! :D ↩ (...)" nil nil "0e720090b1e1d7d1d77c404c9fb9d15e") (13 (26603 40582 559999 604000) "https://emacsredux.com/blog/2025/03/31/essential-flyspell/" "Essential Flyspell" nil "Mon, 31 Mar 2025 19:52:00 +0000" "I’ve been a long time user of flyspell-mode and flyspell-prog-mode, but admittedly I keep forgetting some of it’s keybindings. And there aren’t that many of them to begin with! This article is my n-th attempt to help me memorize anything besides C-c $. So, here we go: M-t (flyspell-auto-correct-word) - press this while in word with typo in it to trigger auto-correct. You can press it repeatedly to cycle through the list of candidates. C-, (flyspell-goto-next-error) - go to the next typo in the current buffer C-. (flyspell-auto-correct-word) - same as M-t C-; (flyspell-auto-correct-previous-word) - automatically correct the last misspelled word. (you can cycle here as well) Last, but not least, there’s the only command I never forget - C-c $ (flyspell-correct-word-before-point). Why is this my go-to command? Well, its name is a bit misleading, as it can do two things: auto-correct the word at (or before) point add the same word to your personal dictionary, so Flyspell and ispell will stop flagging it Good stuff! There are more commands, but those are the ones you really need to know.1 If you ever forget any of them, just do a quick C-h m RET flyspell-mode. Do you have some tips to share about using flyspell-mode (and maybe ispell as well)? That’s all I have for you today! Keep fixing those typos! P.S. If you’re completely new to flyspell-mode, you may want to check this article on the subject as well. Unless you’d like to trigger auto-correct with your mouse, that is. ↩ (...)" nil nil "cacb4a63a58589e8f25160486ae4a9a8") (12 (26598 40085 202899 573000) "https://emacsredux.com/blog/2025/03/28/speed-up-emacs-startup-by-tweaking-the-gc-settings/" "Speed up Emacs Startup by Tweaking the GC Settings" nil "Fri, 28 Mar 2025 08:06:00 +0000" "A well-known Emacs performance optimization advice is to boost the garbage collector threshold (so GC collections happen less frequently). That’s something I’ve had in my Emacs config for ages: ;; reduce the frequency of garbage collection by making it happen on ;; each 50MB of allocated data (the default is on every 0.76MB) (setq gc-cons-threshold 50000000) Probably I should increase it to 100MB+ these days, given the proliferation of more resource-hungry tooling (e.g. LSP). On the other hand there are also some counter arguments to consider when it comes to setting a high GC threshold: The GC threshold setting after init is too high, IMNSHO, and its value seems arbitrary. If the OP thinks that Emacs will GC as soon as it allocates 100 MiB, then that’s a grave mistake! What really happens is the first time Emacs considers doing GC, if at that time more than 100 MiB have been allocated for Lisp objects, Emacs will GC. And since neither Lisp programs nor the user have any control on how soon Emacs will decide to check whether GC is needed, the actual amount of memory by the time Emacs checks could be many times the value of the threshold. My advice is to spend some time measuring the effect of increased GC threshold on operations that you care about and that take a long enough time to annoy, and use the lowest threshold value which produces a tangible improvement. Start with the default value, then enlarge it by a factor of 2 until you see only insignificant speedups. I would not expect the value you arrive at to be as high as 100 MiB. – Eli Zaretskii, Emacs maintainer One thing that’s not so common knowledge is that removing the GC limits during Emacs startup might improve the speedup quite a lot (the actual results will be highly dependent on your setup). Here’s what you need to do - just add the following bit to your early-init.el: ;; Temporarily increase GC threshold during startup (setq gc-cons-threshold most-positive-fixnum) ;; Restore to normal value after startup (e.g. 50MB) (add-hook 'emacs-startup-hook (lambda () (setq gc-cons-threshold (* 50 1024 1024)))) most-positive-fixnum is a neat constant that represents the biggest positive integer that Emacs can handle. There’s also most-negative-fixnum that you might find handy in some cases. As for early-init.el - it was introduced in version 27 and is executed before init.el. Its primary purpose is to allow users to configure settings that need to take effect early in the startup process, such as disabling GUI elements or optimizing performance. This file is loaded before the package system and GUI initialization, giving it a unique role in customizing Emacs startup behavior. Here are some other settings that people like to tweak in early-init.el: ;; Disable toolbars, menus, and other visual elements for faster startup: (menu-bar-mode -1) (tool-bar-mode -1) (scroll-bar-mode -1) (setq inhibit-startup-screen t) ;; Load themes early to avoid flickering during startup (you need a built-in theme, though) (load-theme 'modus-operandi t) ;; tweak native compilation settings (setq native-comp-speed 2) I hope you get the idea! If you have any other tips on speeding up the Emacs startup time, I’d love to hear them! That’s all I have for you today. Keep hacking! (...)" nil nil "7d23f0cafc7381c3f23934dd53750a56") (11 (26598 25802 411831 793000) "https://emacsredux.com/blog/2025/03/28/speed-up-emacs-startup-by-tweaking-the-gc-settings/" "Speed up Emacs Startup by Tweaking the GC Settings" nil "Fri, 28 Mar 2025 08:06:00 +0000" "A well-known Emacs performance optimization advice is to boost the garbage collector threshold (so GC collections happen less frequently). That’s something I’ve had in my Emacs config for ages: ;; reduce the frequency of garbage collection by making it happen on ;; each 50MB of allocated data (the default is on every 0.76MB) (setq gc-cons-threshold 50000000) Probably I should increase it to 100MB+ these days, given the proliferation of more resource-hungry tooling (e.g. LSP). One thing that’s not so common knowledge is that removing the GC limits during Emacs startup might improve the speedup quite a lot (the actual results will be highly dependent on your setup). Here’s what you need to do - just add the following bit to your early-init.el: ;; Temporarily increase GC threshold during startup (setq gc-cons-threshold most-positive-fixnum) ;; Restore to normal value after startup (e.g. 50MB) (add-hook 'emacs-startup-hook (lambda () (setq gc-cons-threshold (* 50 1024 1024)))) most-positive-fixnum is a neat constant that represents the biggest positive integer that Emacs can handle. There’s also most-negative-fixnum that you might find handy in some cases. As for early-init.el - it was introduced in version 27 and is executed before init.el. Its primary purpose is to allow users to configure settings that need to take effect early in the startup process, such as disabling GUI elements or optimizing performance. This file is loaded before the package system and GUI initialization, giving it a unique role in customizing Emacs startup behavior. Here are some other settings that people like to tweak in early-init.el: ;; Disable toolbars, menus, and other visual elements for faster startup: (menu-bar-mode -1) (tool-bar-mode -1) (scroll-bar-mode -1) (setq inhibit-startup-screen t) ;; Load themes early to avoid flickering during startup (you need a built-in theme, though) (load-theme 'modus-operandi t) ;; tweak native compilation settings (setq native-comp-speed 2) I hope you get the idea! If you have any other tips on speeding up the Emacs startup time, I’d love to hear them! That’s all I have for you today. Keep hacking! (...)" nil nil "baa6650dd6554b5e0b8a0f0171f881c9") (10 (26588 11779 491290 777000) "https://emacsredux.com/blog/2025/03/19/relative-line-numbers/" "Relative Line Numbers" nil "Wed, 19 Mar 2025 11:49:00 +0000" "Relative line numbers (relative to the current line) are super popular in the world of Vim, because there it’s super easy to move n lines up or down wiht j and k. In the world of Emacs most of us tend to just go some line using M-g g using a absolute line number or using avy (avy-goto-line). That being said, relative line numbers are easy to enable in Emacs and quite handy if you’re into evil-mode: (setq display-line-numbers-type 'relative) (global-display-line-numbers-mode +1) Relative line numbers are useful with the Emacs core commands forward-line (C-n) and previous-line (C-p) as well. Just trigger them with the universal prefix C-u and you can move quickly around: C-u 5 C-n (move 5 lines forward) C-u 10 C-p (move 10 lines backward) Easy-peasy! That’s all I have for you today! Keep hacking! (...)" nil nil "ebe1fce24c2c73bdf139f9846418732e") (9 (26588 11779 491120 419000) "https://emacsredux.com/blog/2025/03/18/you-have-no-idea-how-powerful-isearch-is/" "You have no idea how powerful isearch is!" nil "Tue, 18 Mar 2025 16:47:00 +0000" "isearch is probably one of the most widely known Emacs commands. Every Emacs user knows that they can run it using C-s (to search forward) and C-r to search backwards. Everyone also knows they can keep pressing C-s and C-r to go over the list of matches in the current buffer. Even at this point that’s a very useful command. But that doesn’t even scratch the surface of what isearch can do! After you’ve started isearch you can actually do a lot more than pressing C-s and C-r: Type DEL to cancel last input item from end of search string. Type RET to exit, leaving point at location found. Type LFD (C-j) to match end of line. Type M-s M-< to go to the first match, M-s M-> to go to the last match. (super handy) Type C-w to yank next word or character in buffer onto the end of the search string, and search for it. (very handy) Type C-M-d to delete character from end of search string. Type C-M-y to yank char from buffer onto end of search string and search for it. Type C-M-z to yank from point until the next instance of a specified character onto end of search string and search for it. Type M-s C-e to yank rest of line onto end of search string and search for it. Type C-y to yank the last string of killed text. Type M-y to replace string just yanked into search prompt with string killed before it. Type C-q to quote control character to search for it. Type C-x 8 RET to add a character to search by Unicode name, with completion. C-g while searching or when search has failed cancels input back to what has been found successfully. C-g when search is successful aborts and moves point to starting point. You can also toggle some settings write isearch is active: Type M-s c to toggle search case-sensitivity. Type M-s i to toggle search in invisible text. Type M-s r to toggle regular-expression mode. Type M-s w to toggle word mode. Type M-s _ to toggle symbol mode. Type M-s ' to toggle character folding. Type M-s SPC to toggle whitespace matching. In incremental searches, a space or spaces normally matches any whitespace defined by the variable search-whitespace-regexp; see also the variables isearch-lax-whitespace and isearch-regexp-lax-whitespace. Type M-s e to edit the search string in the minibuffer. That one is super useful! Also supported is a search ring of the previous 16 search strings: Type M-n to search for the next item in the search ring. Type M-p to search for the previous item in the search ring. Type C-M-i to complete the search string using the search ring. Last, but not least - you can directly search for the symbol/thing at point: Type M-s . to search for the symbol at point. (useful in the context of programming languages) Type M-s M-. to search for the thing (e.g. word or symbol) at point. One of the most useful parts of that is the fact that a region is a thing. So you can mark a region (e.g. with expand-region or mark-*) and M-s M-. to immediately search for other instances of that text. Powerful stuff! Tip: You don’t really have to remember all those keybindings - just remember you can press C-h b to show them. (after you’ve started isearch) Most of the above text is coming straight from the docstring of isearch. It’s funny that I’ve been using Emacs for almost 20 years, I use isearch numerous times every day and I still often forget about much of its functionality. There’s more to isearch, though. Did you know it’s widely customizable as well? If you check its options with M-x customize-group isearch you’ll see there are over 30 (!!!) options there! Admittedly, I never used any of them, but you’ve got quite a lot of opportunities to tweak the behavior of isearch if you want to. Here’s an example of a customization some of you might find useful: ;; When isearching, enable M-<, M->, C-v and M-v to skip between matches ;; in an intuitive fashion. Note that the `cua-selection-mode' bindings ;; for C-v and M-v bindings are not supported. (setq isearch-allow-motion t isearch-motion-changes-direction t) I hope you learned something useful today! Keep searching (the Emacs docs)! (...)" nil nil "381deb571a46851a99eecd8d7a875455") (8 (26588 11779 490818 438000) "https://emacsredux.com/blog/2025/03/03/the-role-of-the-escape-key-in-emacs/" "The role of the Escape key in Emacs" nil "Mon, 03 Mar 2025 07:50:00 +0000" "The Escape key (ESC) is legendary in vim, Emacs’s arch-rival. It’s so commonly used (mostly to switch back to normal mode and interrupt commands in progress) that you’ll find many articles on where to remap it (e.g. to Caps Lock), and there are also many keyboards that place ESC where ~ normally is, to make it more accessible.1 In Emacs-land, however, we never really speak about ESC… Why so? Well, we use C-g to interrupt commands, and we obviously don’t have modal editing, at least not by default. Still, I think ESC has its uses in Emacs, even if they are not super obvious at first. For instance there’s the keyboard-escape-quit command, that’s described like this: Exit the current “mode” (in a generalized sense of the word). This command can exit an interactive command such as ‘query-replace’, can clear out a prefix argument or a region, can get out of the minibuffer or other recursive edit, cancel the use of the current buffer (for special-purpose buffers), or go back to just one window (by deleting all but the selected window). Basically, it’s a fancier way of doing C-g (keyboard-quit), and it’s mapped to ESC ESC ESC (triple escape). Not the most convenient keybinding, but still OK if your Escape is well positioned and you’d like to avoid holding down a modifier key.2 If you take a look at the keybinding in Emacs’s docs, though, you’ll see it’s listed as M-ESC ESC, rather than ESC ESC ESC. And this is what makes ESC really interesting - it serves as a substitute for Meta, but you don’t have to hold down ESC - instead M-something keybindings can be triggered by pressing ESC and the other key sequentially. Go ahead and try the following: ESC x (same as M-x) ESC g g (goto-line, same as M-g g) ESC e (forward-sentence, same as M-e) I don’t know about you, but I think this is pretty handy, especially if you’re using macOS, where on many keyboards the Option (Meta) keys are pretty short, or one of them is even missing (the right one). For me using Emacs on macOS has always been a bit of a struggle, as the Meta is way more useful than Command (Super), and historically I swapped them3 because of this, but then I struggled when I had to use someone else’s keyboard. (or even my own, as I normally contained this rebinding only to Emacs). So, the ability to use ESC instead of Meta is definitely a welcome one, and I find myself doing this quite often. Before we wrap up consider keybindings like M->, M-! or M-% that require you to hold down both Shift and Meta when typing them. I think they way more pleasant as: Esc > Esc ! Esc % Admittedly, it took me a while to get used to this, as I didn’t pay much to the ESC key until I was fairly far into my Emacs journey. Topics like RSI prevention and keybinding ergonomics rarely bother young people. So, did you know about the role of ESC in Emacs? Are you making use of it? If you have any other tips to share on the subject I’d be happy to read them. That’s all I have for you today! ESC x forever! HHKB is probably the most famous example, but there are many many others that do the same. ↩ I’m using a dual-function keybinding for what’s normally Caps Lock on most keyboards - it’s Control wwhen held down and Escape otherwise. For me that’s a good idea regardless of the editor someone’s using. ↩ See https://batsov.com/articles/2012/10/14/emacs-on-osx/. ↩ (...)" nil nil "50c7b239fb96e6fcd073ce4b98f86a1d") (7 (26588 11779 490551 977000) "https://emacsredux.com/blog/2025/03/01/debugging-errors-in-emacs/" "Debugging Errors in Emacs" nil "Sat, 01 Mar 2025 16:36:00 +0000" "I recently wrote an article on debugging Emacs commands. In it I mentioned M-x toggle-debug-on-error and debug-on-error briefly, but after posting the article I realized that many people probably don’t understand how this works exactly. The obvious thing that happens when debug-on-error is enabled is that when an error happen you’re seeing its backtrace (or stacktrace, depending on the terminology you prefer). What’s not so obvious (even, if it’s in the name) is that this buffer is actually a debugger buffer and you can do a lot with it. Here are a few examples: Navigate the Stack Trace: Move your cursor in the *Backtrace* buffer to different lines representing various stack frames. Examine Local Variables: Press v (debugger-toggle-locals) while on a stack frame to display local variables for that frame. Evaluate Expressions: Use e (debugger-eval-expression) to evaluate Lisp expressions in the context of the current frame. Step Through Code: Use d to step into function calls and evaluate expressions one by one. Continue Execution: Press c to continue normal execution. (note, that unless you change something, this will result in the error you’re trying to debug) Quit Debugging: Enter q to exit the debugger and abort the current command. View Help: Type ? to see a list of available debugger commands. Record Evaluations: Use E to evaluate an expression and save the result in the Debugger-record buffer. It’s important to understand that debugger runs in the environment of the error, allowing you to examine variable values precisely as they were at the time of the error. This makes it a powerful tool for understanding and fixing issues in your Emacs Lisp code. That debugging experience is one of the most powerful features of Lisps in general, and it’s one of the reasons why developing and debugging Emacs packages is pretty pleasant and productive experience. Provided you’re familiar with how to use the debugger in such cases that it. You can more help inside Emacs by pressing C-h m while in a debugger buffer. So, to recap - in case you run into some errors you should run the command M-x toggle-debug-on-error, re-run whatever action caused the error and then navigate the stacktrace in the debugger to figure out what went wrong exactly. To debug an error that happens during loading of the init file, use the option --debug-init. This binds debug-on-error to t while loading the init file, and bypasses the condition-case which normally catches errors in the init file. That’s all I have for you today. I hope you’ve learned something useful today and next time you run into some error you’ll be able to fix it in no time! (...)" nil nil "d7c152f204b8d3d6aaf243552dac63fe") (6 (26588 11779 490364 127000) "https://emacsredux.com/blog/2025/02/13/customizing-color-themes/" "Customizing Color Themes" nil "Thu, 13 Feb 2025 08:23:00 +0000" "Every now and then you’d be trying out a new color theme, that you really like overall, but you’d like to tweak a bit here and there to make it perfect. After all, that’s what Emacs is all about - creating the perfect editor for yourself. Sometimes you might be dealing with missing face definitions or configuration options that you might want to submit upstream, but most of the time the changes you’d like to see are probably quite subjective and belong in your personal config. So, how do you make those changes? There are 3 common ways to adjust font faces in Emacs and I’ll briefly cover all of them. Option number 1 is the tried and true classic custom-set-faces: (custom-set-faces '(region ((t (:inherit nil :background \"RoyalBlue4\")))) '(highlight ((t (:inherit region :background \"dark olive green\")))) '(hl-line ((t (:inherit highlight))))) That’s what gets generate if you’re adjusting faces with something like M-x customize-face. The bad thing about this approach is that those customizations will active regardless of your currently selected color theme and if you like to switch themes that’s not cool. Fortunately, it’s easily to narrow customizations to a particular theme with custom-theme-set-faces: (custom-theme-set-faces 'zenburn '(region ((t (:inherit nil :background \"RoyalBlue4\")))) '(highlight ((t (:inherit region :background \"dark olive green\")))) '(hl-line ((t (:inherit highlight))))) Looking good! Note: custom-set-faces works by calling custom-theme-set-faces for the user theme, a special theme referring to settings made via Customize. Finally, you can just set a specific face using set-face-attribute like this: (set-face-attribute 'font-lock-builtin-face nil :weight 'bold) I’d suggest perusing the documentation of set-face-attribute (e.g. with C-h f) as it explains in great detail all the possible attributes you can configure for a font face. The number of properties you can set is truly epic, but most of the time you’ll need to tweak only a couple of them. (e.g. :foreground, :background, etc) Technically speaking, you can go a step further than that and define your own theme that extends the color theme you want to modify1, but that’s an overkill unless you plan to distribute this theme as a package. All the examples above are kind of random, so I’ll conclude here with some real modifications I do in my config to the popular Catppuccin theme: (use-package catppuccin-theme :config ;; or 'latte, 'macchiato, or 'mocha (setq catppuccin-flavor 'macchiato) (load-theme 'catppuccin t) (custom-theme-set-faces 'catppuccin ;; by default the theme uses the same face as for comments, which is wrong IMO '(font-lock-doc-face ((t (:foreground (catppuccin-color 'green))))) ;; font-lock variable definitions like function definitions '(font-lock-variable-face ((t (:inherit font-lock-function-face)))))) The example above also shows how to access the colors from the palette of some color theme outside of its definition. Usually themes provide some API like theme-name-color to get able to get the color codes easily. Funny enough, as I’m writing this I realized that use-package actually has built-in support for customizing faces that I could have used instead. Here’s an example of that in action: (use-package zenburn-theme :preface (setq my/zenburn-colors-alist '((fg . \"#DCDCCC\") (bg . \"#1C1C1C\") (cyan . \"#93E0E3\"))) :custom-face (region ((t (:background ,(alist-get my/zenburn-colors-alist 'cyan))))) :config (load-theme 'zenburn t)) This example also reminded me that I should expose the Zenburn colors via functions. So, to summarize: If you’re using use-package it’s probably best to use it’s :custom-face functionality. The rest of the time you most likely need custom-theme-set-faces. One thing is certain - with Emacs there always numerous ways to achieve something! Note: To see the new font faces in action you’ll either have to restart Emacs or evaluate Elisp code that sets them. (e.g. with C-x C-e) One final tip - if you’re wondering what’s the face used by some text, the best way to figure it out is with the M-x describe-char command. It will give you a ton of information, including something like this near the end: There are text properties here: face (font-lock-keyword-face markdown-code-face) font-lock-fontified t font-lock-multiline t fontified t markdown-gfm-code (2617 3092) I had placed my cursor over the word “use-package” in the code snippet above, while writing this article in markdown-mode, therefore the faces font-lock-keyword-face (coming from elisp-mode) and markdown-code-face (from markdown-mode). Do you have any tips on customizing color themes that you’d like share? That’s all I have for you today. Keep hacking! Remember that Emacs allows you load multiple themes with them stacking one upon another. ↩ (...)" nil nil "4138ad40d07d0f46c7c0427ffaef87cb") (5 (26588 11779 490094 334000) "https://emacsredux.com/blog/2025/02/03/clean-unloading-of-emacs-themes/" "Clean Unloading of Emacs Themes" nil "Mon, 03 Feb 2025 16:27:00 +0000" "If you’re like me, you probably like playing with new Emacs color themes from time to time. Sure, I’m the person behind the Emacs ports of Zenburn and Solarized, but as much as I like them, even I get bored with them occasionally.1 What I often do is to install a bunch of themes (e.g. using M-x package-install) and to quickly try them out by evaluating snippets like the ones below in Emacs: (load-theme 'catppuccin t) (load-theme 'dracula t) (load-theme 'gruvbox t) One small problem with this, though, is that Emacs themes were designed in such a way that one theme can be applied on top of another one. (loading a new theme doesn’t unload the previusly loaded one) In practice this often means that if you load a few themes one after another they’ll start to mess each other up. There are several ways to address this, the simplest being to call disable-theme every time before loading a new theme: (load-theme 'catppuccin t) (disable-theme 'catppuccin) (load-theme 'dracula t) (disable-theme 'dracula) (load-theme 'gruvbox t) Or you can get more adventurous and create a small command that unloads all loaded themes, effectively resetting the theme to Emacs’s default one: (defun er-disable-all-active-themes () \"Disable all currently active themes.\" (interactive) (dolist (theme custom-enabled-themes) (disable-theme theme))) Now, you can simply do M-x disable-all-active-themes when you see fit. Finally, you can consider creating a function complementary to load-theme that unloads all active themes before loading the new one: (defun er-load-theme (theme) (er-disable-all-active-themes) (load-theme theme t)) (er-load-theme 'catppuccin t) (er-load-theme 'dracula t) (er-load-theme 'gruvbox t) Pretty neat! That’s all I have for you on this subject. Keep hacking! P.S. If you’re afraid of Elisp there are a couple of alternative approaches you might consider: The built-in command M-x customize-themes The consult-theme from the popular consult package Both are also great options for previewing themes! Zenburn is to this day my all time favorite theme, though. I rarely manage to spend more than a few days away from it. ↩ (...)" nil nil "57c6eaa873426f127245c8782ea0a900") (4 (26588 11779 489928 8000) "https://emacsredux.com/blog/2025/02/03/debugging-emacs-commands/" "Debugging Emacs Commands" nil "Mon, 03 Feb 2025 10:20:00 +0000" "If you’re using Emacs long enough sooner or later you’ll run into some Emacs command that’s misbehaving and you’ll need to debug it somehow.1 If the command is just blowing up, probably you’ll be able to figure out what’s going on by looking at its backtrace. To get meaningful backtraces you can either run M-x toggle-debug-on-error or add this to your Emacs config: (setq debug-on-error t) Sometimes that will be enough, but other times you’ll need to dig deeper… Fortunately for us Emacs features a super powerful built-in Emacs Lisp debugger and using it is the best way to diagnose problems of any kind.2 To debug some command you need to do the following: Figure out the name of the command you want to debug (e.g. by using C-h k to see which command is associated with some keybinding) Find the source of the command (e.g. by using M-x find-function RET function-name) Press C-u C-M-x while in the body of the function Run the command again At this point you’ll be dropped in the debugger and you can step forward (by pressing n) until you find the problem. The debugger is quite powerful and you can do way more than just stepping through the code, though. Here are some of the most useful commands to run in it: n (next): Step over the next expression d (step): Step into a function call c (continue): Continue execution until the next breakpoint e (eval): Evaluate a Lisp expression in the current context b (break): Set a breakpoint at a specific line or function u (unset): Remove a breakpoint q (quit): Exit the debugger r (return): Specify a return value and continue execution ? (help): Shows the full list of debugger commands. You can read more about the debugger commands here. I would also suggest reading the short tutorial in Emacs’s manual. I use this approach all time and it’s very efficient. It’s also not specific to commands and works great for all Emacs Lisp code. Every Emacs user will do well to invest a bit of time into learning the basics of debugging Emacs Lisp code. By the way, it’s probably not super obvious but when an error happens and you’ve enabled debug-on-error (e.g. with M-x toggle-debug-on-error), you’re not just getting a backtrace, but a backtrace - that’s actually another way in which you can interact with the Emacs debugger. Press ? while in this buffer or check out this short article for more details. That’s all I have for you today. Keep hacking! Emacs commands are simply Emacs Lisp functions that can be invoked interactively with M-x. ↩ Here’s a great crash course on using the debugger. ↩ (...)" nil nil "94acb18c8b562d18dc346c43441b4fb8") (3 (26588 11779 489736 848000) "https://emacsredux.com/blog/2025/01/12/emacs-and-xdg-sitting-on-a-tree/" "Emacs and XDG sitting on a tree" nil "Sun, 12 Jan 2025 16:34:00 +0000" "Where to place my Emacs configuration? That is the question! This fairly simple question has surprisingly many answers, as it often happens with projects as old as Emacs: Historically Emacs’s user config was a file called .emacs, placed in your home directory Later you could use the name init.el as an alias to .emacs And then there’s the option that’s probably most common today - placing your configuration under the .emacs.d folder, where you usually have an init.el that potentially refers to other Emacs Lisp libraries But wait, there’s more! Emacs 27.1 introduced XDG_CONFIG_HOME support, and Emacs 29.1 extended the level of XDG base directory specification support in Emacs. XDG, which stands for X Desktop Group, is a set of standards and specifications developed by freedesktop.org to promote interoperability among different desktop environments, primarily in Unix-like operating systems. The group focuses on ensuring that applications can work seamlessly across various desktop environments by adhering to common guidelines. Their most notable work to date is the XDG base directory specification. In a nutshell this specification outlines the environment variables that define where user-specific data files, configuration files, and cache files should be stored. For instance, it specifies directories like $XDG_CONFIG_HOME for configuration files and $XDG_DATA_HOME for data files.1 Most of the time the XDG config home would be ~/.config and there would be a subfolder there for the configuration of each application. In Emacs’s case that would be ~/.config/emacs. I hope it’s clear that the idea here is to reduce the clutter at the top-level and to make sure that each application stores its configuration in a predictable place. I think it’s really great that Emacs is (slowly) adopting the industry standards and I believe that over the course of time the XDG config folder will become the preferred place to store your Emacs configuration. That’s why I encourage everyone to move in this direction and unclutter their home folder a bit. Just keep in mind a couple of things: You’ll have to make sure that folders like ~/.emacs.d don’t exist anymore, as they’d have precedence over the XDG config folder. The configuration resolution happens like this: Emacs looks for your init file using the filenames ~/.emacs.el, ~/.emacs, or ~/.emacs.d/init.el in that order; you can choose to use any one of these names. (Note that only the locations directly in your home directory have a leading dot in the location’s basename.) Emacs can also look in an XDG-compatible location for init.el, the default is the directory ~/.config/emacs. This can be overridden by setting XDG_CONFIG_HOME in your environment, its value replaces ~/.config in the name of the default XDG init file. However ~/.emacs.d, ~/.emacs, and ~/.emacs.el are always preferred if they exist, which means that you must delete or rename them in order to use the XDG location. Note also that if neither the XDG location nor ~/.emacs.d exist, then Emacs will create ~/.emacs.d (and therefore use it during subsequent invocations). Emacs will set user-emacs-directory to the directory it decides to use. Not the best defaults IMO (especially falling back to creating .emacs.d), but you can’t fight tradition! Or rather - fighting tradition is pretty hard… Some packages might have hardcoded the path in which they store their own configuration. In general they should be relying on user-emacs-directory, which will be auto-set to whatever directory Emacs discovered its configuration in, but there will always be some packages that probably didn’t do “the right thing”. I’m guessing that we’re not really getting rid of ~/.emacs.d any time soon (or ever), but I’m hoping that article like this one might speed up a bit the process. Time will tell. macOS users should keep in mind that unfortunately macOS doesn’t set the standard XDG environment variables, as it has its own notion of where things like configuration files, application cache, etc should be stored. Still, it’s fairly easy to just set the missing variables yourself (e.g. in your .zshrc): export XDG_CONFIG_HOME = $HOME/.config export XDG_DATA_HOME = $HOME/.local/share export XDG_STATE_HOME = $HOME/.local/state export XDG_CACHE_HOME = $HOME/.cache So, has anyone moved their Emacs config to respect the XDG conventions already? How smooth was the process for you? P.S. If you’re curious to learn more about how Emacs’s configuration discover process I’d suggest reading this chapter of the Emacs Manual. Good stuff! Check out the XDG base directory specification for more details. ↩ (...)" nil nil "9e3e3c9d3e1ba26f3bba6563c385ea4f") (2 (26588 11779 489455 632000) "https://emacsredux.com/blog/2025/01/12/ensure-all-packages-are-installed-by-default-with-use-package/" "Ensure all packages are installed by default with use-package" nil "Sun, 12 Jan 2025 16:12:00 +0000" "I’m quite fond of use-package and I’ve organized my personal Emacs setup around it for a while now. One thing that I don’t like very much is that by default almost I have to add :ensure t to almost every use-package block, as I want all external packages to be installed if they are not present. That’s quite handy when I’m setting up Emacs on a new computer.1 Think something like: (use-package zenburn-theme :ensure t :config (load-theme 'zenburn t)) Not a big deal for a few packages, but kind of annoying if you have 50+ packages in your init.el. There’s a pretty simple solution to this problem, though. Just add the following bit of configuration to your Emacs setup: (setq use-package-always-ensure t) Now instead of specifying :ensure t you can specify :ensure nil for the packages you don’t want to install automatically. Note that for built-packages (e.g. dired) it doesn’t really matter if a package is using :ensure t or :ensure nil.2 Which approach do you prefer? Are you the type of person who ensures every package is installed when absent or not? Why do you prefer one approach over the other? I know that a lot of people object to this approach, as you’re not sure what versions of the packages you’d get as package.el is a bit primitive compared to something like Ruby’s Bundler or Node’s npm, but in practice I’ve rarely had issues with my approach and it has saved me a great deal of time. ↩ package-installed-p will return t for those. ↩ (...)" nil nil "e4fef239f1cccc2ebfe94ce3fc77b75f") (1 (26588 11779 489286 224000) "https://emacsredux.com/blog/2024/03/11/tracking-world-time-with-emacs/" "Tracking World Time with Emacs" nil "Mon, 11 Mar 2024 09:38:00 +0000" "In today’s highly connected world it’s often useful to keep track of time in several time zones. I work in a company with employees all over the world, so I probably keep track of more time zones than most people. So, what are the best ways to do this? I know what you’re thinking - let’s just buy an Omega Aqua Terra Worldtimer mechanical watch for $10,000 and be done with it!1 While this will definitely get the job done and improve the looks of your wrist immensely, there’s a cheaper and more practical option for you - Emacs. Did you know that Emacs has a command named world-clock that does exactly what we want?2 If you invoke it you’ll see something like this: Seattle Monday 11 March 02:45 PDT New York Monday 11 March 05:45 EDT London Monday 11 March 09:45 GMT Paris Monday 11 March 10:45 CET Bangalore Monday 11 March 15:15 IST Tokyo Monday 11 March 18:45 JST Hmm, looks OK but the greatest city in the world (Sofia, Bulgaria) is missing from the list… That’s totally unacceptable! We can fix this by tweaking the variable world-clock-list: (setq world-clock-list '((\"America/Los_Angeles\" \"Seattle\") (\"America/New_York\" \"New York\") (\"Europe/London\" \"London\") (\"Europe/Paris\" \"Paris\") (\"Europe/Sofia\" \"Sofia\") (\"Asia/Calcutta\" \"Bangalore\") (\"Asia/Tokyo\" \"Tokyo\"))) Let’s try M-x world-clock again now: Seattle Monday 11 March 02:51 PDT New York Monday 11 March 05:51 EDT London Monday 11 March 09:51 GMT Paris Monday 11 March 10:51 CET Sofia Monday 11 March 11:51 EET Bangalore Monday 11 March 15:21 IST Tokyo Monday 11 March 18:51 JST Much better! By the way, you don’t really have to edit world-clock-list, as by default it’s configured to mirror the value of zoneinfo-style-world-list. The choice is yours. You can also configure the way the world time entries are displayed using world-clock-time-format. Let’s switch to a style with shorter day and month names: (setq world-clock-time-format \"%a %d %b %R %Z\") This will result in: Seattle Mon 11 Mar 06:06 PDT New York Mon 11 Mar 09:06 EDT London Mon 11 Mar 13:06 GMT Paris Mon 11 Mar 14:06 CET Sofia Mon 11 Mar 15:06 EET Bangalore Mon 11 Mar 18:36 IST Tokyo Mon 11 Mar 22:06 JST Check out the docstring of format-time-string (C-h f format-time-string) for more details, as the options here are numerous. That’s all I have for you today. I hope you learned something useful. Keep hacking! Mechanical watches are another passion of mine. ↩ It was named display-time-world before Emacs 28.1. The command was originally introduced in Emacs 23.1. ↩ (...)" nil nil "ab3857592e43e01ed6002bae1ee03d2a")))